SCHC (pronounced chic) is the compression mechanism for LPWAN networks standardized at the IETF.

--- abstract

This implementation deals with the way in which Static Context Header Compression can be applied to CoAP/UDP/IPv6 headers in an LPWAN flow regarding the generated traffic. 

This specific application was developed for LoRaWAN with end-devices of class A (bi-directional end-devices).   

--- middle

# Introduction

This document describes the application of generic compression/decompression processes defined in {{I-D.toutain-lpwan-ipv6-static-context-hc}} and {{I-D.toutain-lpwan-coap-static-context-hc}}.

For the moment the implementation was tested only for the uplink, communicating from the End-Systems (ES) to the LPWAN Compressor/Decompressor (LC). 

A CoAP/UDP/IPv6 packet is generated by the ES, the ES parses this packet to obtain each value of the header fields, then the ES searches for a compression rule that matches this packet format. If there is a rule in the context that matches the header format of the packet, the header fields are compressed using the Compression/Decompression Function (CDF) specified by that rule and the compressed packet is sent to the LC.

Once the LC receives the compressed packet, the packet is parsed by the LC to obtain the rule (first byte), and afterwards each header field sent (according to the rule) and the payload. Finally the LC decompresses the header received following the rule received.

For this purpose the ES used was a LoPy which is able to transmit via LoRa and can be easily programmed in MicroPython. The LC is implemented with a Node.js by a HTTP Server which receives the raw compressed packet, the ESiid and the LAiid.

# Compression and decompression

## Compression (ES)

For the compression in the ES two main Python modules were developed: *“Parser.py”* and *“Compressor.py”*. These can be found in the folder *“pycom”*. 

To use this module for compression the following steps should be followed:

1. Import the *“Parser”* and *“Compressor”* classes from the modules.

    *from Parser import Parser*
	
    *from Compressor import Compressor*

2. Create these classes to initialize the parser, the compressor and the packet generator.

   *compressor = Compressor()*
   *parser = Parser()*

3. Define the rules following its given format. The format for Python is the following:
4. Add the rules to be used (For the moment, the rules should be added in their correponding oreder, matching the context of the compressor in the ES).

	*compressor.addRule(rule0)*

Now the Compressor is all set up and ready to compress packets to be sent.

For every packet to be sent the following functions should be used:   

5. The packet to be sent has to be parsed first to obtain each value of the header fields before the compressor handles it.

   *parser.parser(packet)*

6. Once the packet has been parsed, the values of the header fields obtained, a list of the CoAP options in the header and the payload must be loaded to the compressor from the parser.
    
    *compressor.loadFromParser(parser.header_fields, parser.coap_header_options, parser.payload)*

7. Then the compressor analyses the header fields and looks for a rule that matches for compression.

   *compressor.analyzePacketToSend()*

8. If a rule is found that matches for all the header fields of the packet the compression can be done following that rule.

   *compressor.compressPacket()*

9. To obtain the compressed packet with the header fields appended and ready to be sent, the function *“returnCompressedPacket()”* can be called.

   *compressor.appendCompressedPacket()*
   
The compressed header packet can then be accessed through the variable *"compressor.compressed_packet"*.

## Decompression (ES)

For the decompression in the ES the Python module *“Decompressor.py”* was developed. These can be found in the folder *“pycom”*. 

To use this module for compression the following steps should be followed:

1. Import the *“Parser”* and *“Compressor”* classes from the modules.

    *from Compressor import Decompressor*

2. Create these classes to initialize the parser, the compressor and the packet generator.

   *decompressor = decompressor()*

3. Define the rules following its given format. The format for Python is the following:
4. Add the rules to be used (For the moment, the rules should be added in their correponding oreder, matching the context of the compressor in the ES).

	*decompressor.addRule(rule0)*

Now the Compressor-Decompressor is all set up and ready to decompress received packets.
For every packet received the following methods should be used in order:

6. The compressed packet received has to be loaded to the Compressor-Decompressor. In this method, the compressed packet is parsed into the rule, the values sent for the fields that have to receive something according to the rule and the payload.
    
    *decompressor.parseCompressedPacket(compressedPacket);*

7. The IPv6 IIDs depending on the rule could be obtained from L2, in this case the following method should be used to load the ES and LA IIDs to the Compressor-Decompressor.

    *decompressor.loadIIDs(ESiid,LAiid);*

8. Following the context of the rule received the decompression can be executed.

    *decompressor.decompressHeader();*

After the decompression, the decompressed header can then be accessed through the variable *"decompressor.decompressed_header"*.

The implementation of the compressor was done in a LoPY and the *“main.py”* shows an example of how to use this device to send previously compressed packets over LoRaWAN and receive compressed packet that are then decompressed.

The folder *“pycom\test”* contains a script called *“testing.py”* that can be used to test the compression of different packets that follow a basic rule loaded as *“rule0”*. Other rules can be added following the rule format.

## Compression (LC)

For the compression in the LC a Javascript module was developed. This can be found in the folder *“javascript\lib”* with the name *“schc_cd.js”*.

To use this module for decompression the following steps should be followed:

1. Import the modules.

    *var Parser = require('./parser');*
    *var Compressor_Decompressor = require('../lib/schc_cd');*
    
2. Create a new object for the Parser and the Compressor-Decompressor.

    *var parser = new Parser();*
    *var CD = new Compressor_Decompressor;*

3. Load the initial values to the Compressor-Decompressor.

    *CD.initializeCD();*

4. Rules should be previously defined following the given format. 
5. Add the rules to be used (For the moment, the rules should be added in their correponding oreder, matching the context of the compressor in the ES).

    *CD.addRule(rule);*

Now the Compressor is all set up and ready to compress packets to be sent.

For every packet to be sent the following functions should be used:   

5. The packet to be sent has to be parsed first to obtain each value of the header fields before the compressor handles it.

   *parser.parser(packet)*

6. Once the packet has been parsed, the values of the header fields obtained, a list of the CoAP options in the header and the payload must be loaded to the compressor from the parser.
    
    *CD.loadFromParser(parser.header_fields, parser.coap_header_options, parser.payload)*

7. Then the compressor analyses the header fields and looks for a rule that matches for compression.

   *CD.analyzePacketToSend()*

8. If a rule is found that matches for all the header fields of the packet the compression can be done following that rule.

   *CD.compressPacket()*

9. To obtain the compressed packet with the header fields appended and ready to be sent, the function *“returnCompressedPacket()”* can be called.

   *CD.appendCompressedPacket()*
   
The compressed header packet can then be accessed through the variable *"CD.compressed_packet"*.

## Decompression (LC)

For the decompression in the LC a Javascript module was developed. This can be found in the folder *“javascript\lib”* with the name *“schc_cd.js”*.

To use this module for decompression the following steps should be followed:

1. Import the module.

    *var Compressor_Decompressor = require('../lib/schc_cd');*

2. Create a new object for the Compressor-Decompressor.

    *var CD = new Compressor_Decompressor;*

3. Load the initial values to the Compressor-Decompressor.

    *CD.initializeCD();*

4. Rules should be previously defined following the given format. 
5. Add the rules to be used (For the moment, the rules should be added in their correponding oreder, matching the context of the compressor in the ES).

    *CD.addRule(rule);*

Now the Compressor-Decompressor is all set up and ready to decompress received packets.
For every packet received the following methods should be used in order:   

6. The IPv6 IIDs depending on the rule could be obtained from L2, in this case the following method should be used to load the ES and LA IIDs to the Compressor-Decompressor.

    *CD.loadIIDs(ESiid,LAiid);*

7. The compressed packet received has to be loaded to the Compressor-Decompressor. In this method, the compressed packet is parsed into the rule, the values sent for the fields that have to receive something according to the rule and the payload.
    
    *CD.parseCompressedPacket(compressedPacket);*

8. Following the context of the rule received the decompression can be executed.

    *CD.decompressHeader();*

After the decompression, the decompressed header can then be accessed through the variable *"CD.decompressed_header"*.

The folder *“javascript\test”* contains a script called *“testing.js”* that can be used to test the decompression of different packets that follow a basic rule loaded as *“rule0”*. Other rules can be added following the rule format.

The folder *“javascript\examples”* contains a script called *“decompression_server.js”* which shows how a server could be set up and use the module to decompress the packets received.

# Limitation

For the moment the compressor does not support downlink communication. Tackling this limitation is the next steps in making a fully functional implementation of the SCHC for LoRAWAN.

# Appendix - Rule Format

An example of a rule format is shown. All fields should be included in a rule for a propper compression/decompression. Note that this example of rule is for Javascript where the "targetValue" of each field is a string, for the Python code the "targetValue" should be expressed in bytes literals (b' ').

    var rule0 = {

    "IP_version": {
    
        "targetValue": "6",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "IP_trafficClass": {
    
        "targetValue": "00",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "IP_flowLabel": {
    
        "targetValue": "00000",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "IP_payloadLength": {
   
    "targetValue": "",
    
        "matchingOperator": "ignore",
	
        "compDecompFct": "compute-IPv6-length",
	
        "direction": "bi"
	
    },
    
    "IP_nextHeader": {
    
        "targetValue": "11",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "IP_hopLimit": {
    
        "targetValue": "40",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "IP_prefixES": {
    
        "targetValue": {
	
            "1": "20010db80a0b12f0",
	    
            "2": "2d513de80a0b4df0"
	    
        },
	
        "matchingOperator": "match-mapping",
	
        "compDecompFct": "mapping-sent(4)",
	
        "direction": "bi"
	
    },
    
    "IP_iidES": {
    
        "targetValue": "",
	
        "matchingOperator": "ignore",
	
        "compDecompFct": "ESiid-DID",
	
        "direction": "bi"
	
    },
    
    "IP_prefixLA": {
    
        "targetValue": {
	
            "1": "20010db80a0b12f0",
	    
            "2": "2d513de80a0b4df0",
	    
        },
	
        "matchingOperator": "match-mapping",
	
        "compDecompFct": "mapping-sent(4)",
	
       	"direction": "bi"
	
    },
    
    "IP_iidLA": {
    
        "targetValue": "",
	
        "matchingOperator": "ignore",
	
        "compDecompFct": "LAiid-DID",
	
        "direction": "bi"
	
    },
    
    "UDP_PortES": {
    
        "targetValue": "1f90",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "UDP_PortLA": {
    
        "targetValue": "2382",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "UDP_length": {
    
        "targetValue": "",
	
        "matchingOperator": "ignore",
	
        "compDecompFct": "compute-UDP-length",
	
        "direction": "bi"
	
    },
    
    "UDP_checksum": {
    
        "targetValue": "",
	
        "matchingOperator": "ignore",
	
        "compDecompFct": "compute-UDP-checksum",
	
        "direction": "bi"
	
    },
    
    "CoAP_version": {
    
        "targetValue": "1",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "CoAP_type": {
    
        "targetValue": "1",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "CoAP_tokenLength": {
    
        "targetValue": "1",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "CoAP_code": {
    
        "targetValue": "02",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "CoAP_messageID": {
    
        "targetValue": "000000000000",
	
        "matchingOperator": "MSB(12)",
	
        "compDecompFct": "LSB(4)",
	
        "direction": "bi"
	
    },
    
    "CoAP_token": {
    
        "targetValue": "",
	
        "matchingOperator": "ignore",
	
        "compDecompFct": "value-sent",
	
        "direction": "bi"
	
    },
    
    "CoAP_Uri-Path 1": {
    
        "targetValue": "b3666f6f",  // "foo"
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "CoAP_Uri-Path 2": {
    
        "targetValue": "",
	
        "matchingOperator": "ignore",
	
        "compDecompFct": "value-sent",
	
        "direction": "bi"
	
    }
    
};
