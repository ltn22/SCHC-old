Static Context Header Compression (SCHC, pronounced chic) is a *generic* compression mechanism for LPWAN networks. It is standardized at the IETF.

--- abstract

This implementation applies SCHC to CoAP/UDP/IPv6 headers.

It targets LoRaWAN end-devices of class A (asymmetric bi-directional).   

--- middle

# Introduction

This document describes the application of generic compression/decompression processes defined in {{I-D.toutain-lpwan-ipv6-static-context-hc}} and {{I-D.toutain-lpwan-coap-static-context-hc}}.

For the moment, the implementation has only been tested on the uplink, communicating from the End-Systems (ES) to the LPWAN Compressor/Decompressor (LC) in the infrastructure. 

A CoAP/UDP/IPv6 packet is generated by the ES, the ES parses this packet to obtain each value of the header fields, then the ES searches for a compression rule that matches this packet format. If there is a rule in the context that matches the header format of the packet, the header fields are compressed using the Compression/Decompression Function (CDF) specified by that rule and the compressed packet is sent over the air to the LC.

Upon receipt, the compresssed packet is parsed by the LC to delineate the rule identifier (first byte), each subsequent header field (as specified by the rule) and the payload. Finally, the LC decompresses the headers, as described in the rule.

For this purpose, the ES is implemented on a LoPy module, which is able to transmit via LoRa and can be easily programmed in MicroPython. The LC is implemented with a Node.js by an HTTP Server which receives the raw compressed packet, the ESiid and the LAiid.

[comment]: # (define the acronyms ESid and LAiid)

# Compression and decompression

## Compression (ES)

For the compression in the ES, two main Python modules were developed: *“Parser.py”* and *“Compressor.py”*. These can be found in the *“pycom”* folder. 

To use this module for compression, the following steps should be followed:

1. Import the *“Parser”* and *“Compressor”* classes from the modules.

    *from Parser import Parser*
	
    *from Compressor import Compressor*

2. Create these classes to initialize the parser, the compressor and the packet generator.

   *compressor = Compressor()*

   *parser = Parser()*

3. Define the rules following its given format. The format for Python is the following:

[comment]: # (DB: I don't understand "Define the rules following its given format")

[comment]: # (missing information after "... is the following")

4. Add the rules to be used (for the moment, the rules should be added in their corresponding order, matching the context of the compressor in the ES).

	*compressor.addRule(rule0)*

Now the Compressor is all set up and ready to compress packets to be sent.

For every packet to be sent, the following functions should be used:   

5. The packet to be sent has first to be parsed to obtain each value of the header fields before the compressor handles it.

   *parser.parser(packet)*

6. Once the packet has been parsed and the values of the header fields obtained, a list of the CoAP options in the header and the payload must be loaded to the compressor from the parser.
    
    *compressor.loadFromParser(parser.header_fields, parser.coap_header_options, parser.payload)*

7. Then the compressor analyses the header fields and looks for a rule that matches for compression.

   *compressor.analyzePacketToSend()*

8. If a rule is found that matches all the header fields of the packet, the compression can be done following that rule.

   *compressor.compressPacket()*

9. To obtain the compressed packet with the header fields appended and ready to be sent, the function *“returnCompressedPacket()”* can be called.

   *compressor.appendCompressedPacket()*

[comment]: # (the above command line does not seem to match the function name in the instruction)
   
The compressed packet can then be accessed through the variable *"compressor.compressed_packet"*.

## Decompression (ES)

For the decompression in the ES, the Python module *“Decompressor.py”* was developed. It can be found in the *“pycom”* folder. 

To use this module for decompression, the following steps should be followed:

1. Import the *“Parser”* and *“Decompressor”* classes from the modules.

    *from Parser import Parser*

    *from Compressor import Decompressor*

2. Create these classes to initialize the parser, the compressor and the packet generator.

   *decompressor = decompressor()*

3. Define the rules following its given format. The format for Python is the following:

[comment]: # (DB: first sentence unclear. second sentence missing its sequel)

4. Add the rules to be used (for the moment, the rules should be added in their corresponding order, matching the context of the compressor in the ES).

	*decompressor.addRule(rule0)*

Now the Compressor-Decompressor is all set up and ready to decompress received packets.
For every packet received, the following methods should be used in order:

6. The compressed packet received has to be loaded to the Compressor-Decompressor. In this method, the compressed packet is parsed into the rule, the values sent for the fields that have to receive something according to the rule and the payload.

[comment]: # (DB: I dont understand the last sentence. I suggest to break it into smaller ones.)
	*decompressor.parseCompressedPacket(compressedPacket)*

7. Depending on the rule, the IPv6 IIDs may have to be obtained from L2. In this case, the following method should be used to load the ES and LA IIDs into the Compressor-Decompressor.

    *decompressor.loadIIDs(ESiid,LAiid);*

8. The decompression can now be executed. This will follow the description of the rule the Id of which was received.

    *decompressor.decompressHeader();*

After the decompression, the decompressed header can then be accessed through the variable *"decompressor.decompressed_header"*.

The implementation of the compressor was done in a LoPY and the *“main.py”* shows an example of how to use this device to send previously compressed packets over LoRaWAN and receive compressed packet that are then decompressed.

The folder *“pycom\test”* contains a script called *“testing.py”* that can be used to test the compression of different packets that follow a basic rule loaded as *“rule0”*. Other rules can be added following the rule format.

## Compression (LC)

For the compression in the LC, a Javascript module was developed. It can be found in the folder *“javascript\lib”* with the name *“schc_cd.js”*.

To use this module for decompression the following steps should be followed:

1. Import the modules.

    *var Parser = require('./parser');*

    *var Compressor_Decompressor = require('../lib/schc_cd');*
    
2. Create a new object for the Parser and the Compressor-Decompressor.

    *var parser = new Parser();*

    *var CD = new Compressor_Decompressor;*

3. Load the initial values to the Compressor-Decompressor.

    *CD.initializeCD();*

4. Rules should be previously defined following the given format. 
5. Add the rules to be used (for the moment, the rules should be added in their corresponding order, matching the context of the compressor in the ES).

    *CD.addRule(rule);*

Now the Compressor is all set up and ready to compress packets to be sent.

For every packet to be sent, the following functions should be used:   

5. The packet to be sent has first to be parsed to obtain each value of the header fields before the compressor handles it.

   *parser.parser(packet)*

6. Once the packet has been parsed and the values of the header fields obtained, a list of the CoAP options in the header and the payload must be loaded to the compressor from the parser.
    
    *CD.loadFromParser(parser.header_fields, parser.coap_header_options, parser.payload)*

7. Then the compressor analyses the header fields and looks for a rule that matches them.

   *CD.analyzePacketToSend()*

8. If a rule is found that matches all the header fields of the packet, the compression can be done following that rule.

   *CD.compressPacket()*

9. To obtain the compressed packet with the header fields appended and ready to be sent, the function *“returnCompressedPacket()”* can be called.

   *CD.appendCompressedPacket()*
   
The compressed header packet can then be accessed through the variable *"CD.compressed_packet"*.

## Decompression (LC)

For the decompression in the LC, a Javascript module was developed. It can be found in the folder *“javascript\lib”* with the name *“schc_cd.js”*.

To use this module for decompression, the following steps should be followed:

1. Import the module.

    *var Compressor_Decompressor = require('../lib/schc_cd');*

2. Create a new object for the Compressor-Decompressor.

    *var CD = new Compressor_Decompressor;*

3. Load the initial values to the Compressor-Decompressor.

    *CD.initializeCD();*

4. Rules should be previously defined following the given format. 
5. Add the rules to be used (for the moment, the rules should be added in their corresponding order, matching the context of the compressor in the ES).

    *CD.addRule(rule);*

Now the Compressor-Decompressor is all set up and ready to decompress received packets.
For every packet received, the following methods should be used in order:   

6. Depending on the rule, the IPv6 IIDs may have to be obtained from L2. In this case, the following method should be used to load the ES and LA IIDs into the Compressor-Decompressor.

    *CD.loadIIDs(ESiid,LAiid);*

7. The compressed packet received has to be loaded to the Compressor-Decompressor. In this method, the compressed packet is parsed into the rule, the values sent for the fields that have to receive something according to the rule and the payload.

[comment]: # (DB: I dont understand the last sentence. I suggest to break it into smaller ones.)
    
    *CD.parseCompressedPacket(compressedPacket);*

8. The decompression can now be executed. This will follow the description of the rule the Id of which was received.

    *CD.decompressHeader();*

After the decompression, the decompressed header can then be accessed through the variable *"CD.decompressed_header"*.

The *“javascript\test”* folder contains a script called *“testing.js”* that can be used to test the decompression of different packets that follow a basic rule loaded as *“rule0”*. Other rules can be added following the rule format.

The folder *“javascript\examples”* contains a script called *“decompression_server.js”* which shows how a server could be set up that uses the module to decompress the packets received.

# Appendix - Rule Format

An example of a rule format is shown. All fields should be included in a rule for a proper compression/decompression. Note that this example of rule is for Javascript where the "targetValue" of each field is a string. For Python code, the "targetValue" should be expressed in bytes literals (b' ').

    var rule0 = {

    "IP_version": {
    
        "targetValue": "6",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "IP_trafficClass": {
    
        "targetValue": "00",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "IP_flowLabel": {
    
        "targetValue": "00000",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "IP_payloadLength": {
   
    "targetValue": "",
    
        "matchingOperator": "ignore",
	
        "compDecompFct": "compute-IPv6-length",
	
        "direction": "bi"
	
    },
    
    "IP_nextHeader": {
    
        "targetValue": "11",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "IP_hopLimit": {
    
        "targetValue": "40",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "IP_prefixES": {
    
        "targetValue": {
	
            "1": "20010db80a0b12f0",
	    
            "2": "2d513de80a0b4df0"
	    
        },
	
        "matchingOperator": "match-mapping",
	
        "compDecompFct": "mapping-sent(4)",
	
        "direction": "bi"
	
    },
    
    "IP_iidES": {
    
        "targetValue": "",
	
        "matchingOperator": "ignore",
	
        "compDecompFct": "ESiid-DID",
	
        "direction": "bi"
	
    },
    
    "IP_prefixLA": {
    
        "targetValue": {
	
            "1": "20010db80a0b12f0",
	    
            "2": "2d513de80a0b4df0",
	    
        },
	
        "matchingOperator": "match-mapping",
	
        "compDecompFct": "mapping-sent(4)",
	
       	"direction": "bi"
	
    },
    
    "IP_iidLA": {
    
        "targetValue": "",
	
        "matchingOperator": "ignore",
	
        "compDecompFct": "LAiid-DID",
	
        "direction": "bi"
	
    },
    
    "UDP_PortES": {
    
        "targetValue": "1f90",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "UDP_PortLA": {
    
        "targetValue": "2382",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "UDP_length": {
    
        "targetValue": "",
	
        "matchingOperator": "ignore",
	
        "compDecompFct": "compute-UDP-length",
	
        "direction": "bi"
	
    },
    
    "UDP_checksum": {
    
        "targetValue": "",
	
        "matchingOperator": "ignore",
	
        "compDecompFct": "compute-UDP-checksum",
	
        "direction": "bi"
	
    },
    
    "CoAP_version": {
    
        "targetValue": "1",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "CoAP_type": {
    
        "targetValue": "1",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "CoAP_tokenLength": {
    
        "targetValue": "1",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "CoAP_code": {
    
        "targetValue": "02",
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "CoAP_messageID": {
    
        "targetValue": "000000000000",
	
        "matchingOperator": "MSB(12)",
	
        "compDecompFct": "LSB(4)",
	
        "direction": "bi"
	
    },
    
    "CoAP_token": {
    
        "targetValue": "",
	
        "matchingOperator": "ignore",
	
        "compDecompFct": "value-sent",
	
        "direction": "bi"
	
    },
    
    "CoAP_Uri-Path 1": {
    
        "targetValue": "b3666f6f",  // "foo"
	
        "matchingOperator": "equal",
	
        "compDecompFct": "not-sent",
	
        "direction": "bi"
	
    },
    
    "CoAP_Uri-Path 2": {
    
        "targetValue": "",
	
        "matchingOperator": "ignore",
	
        "compDecompFct": "value-sent",
	
        "direction": "bi"
	
    }
    
	};

