SCHC (pronounced chic) is the compression mechanism for LPWAN networks standardized at the IETF.

--- abstract

This implementation deals with the way in which Static Context Header Compression can be applied to IPv6/UDP/CoAP headers in an LPWAN flow regarding the generated traffic. 

This specific application was developed for LoRaWAN with end-devices of class A (bi-directional end-devices).   

--- middle

# Introduction

This document describes the application of generic compression/decompression processes defined in {{I-D.toutain-lpwan-ipv6-static-context-hc}} and {{I-D.toutain-lpwan-coap-static-context-hc}}.

For the moment the implementation was tested only for the uplink, communicating from the End-Systems (ES) to the LPWAN Compressor/Decompressor (LC). 

A IPv6/UDP/CoAP packet is generated by the ES, the ES parses this packet to obtain each value of the header fields, then the ES searches for a compression rule that matches this packet format. If there is a rule in the context that matches the header for this packet is compressed using the Compression/Decompression Function (CDF) and the compressed packet is sent to the LC.

Once the LC receives the compressed packet, it is parsed by the LC to obtain the rule (first byte), and afterwards each header field sent according to the rule and the payload. Finally the LC decompresses the header received following the context of the rule received.

For this purpose the ES used was a LoPy which is able to transmit via LoRaWAN and can be easily programmed in MicroPython. The LC is implemented with a Node.js server which receives the message at the HTTP Server with the raw compressed packet, the ESiid and the LAiid.

# Compression and decompression

## Compression (ES)

(ADD LIST OF POSSIBLE MO AND CDF)

## Decompression (LC)

For the decompression in the LC a Javascript module was developed. This can be found in the folder “javascript\lib” with the name “schc_cd.js”.

To use this module for decompression in a Node.js server the following steps should be followed:

1. Import the module.

    *var Compressor_Decompressor = require('../lib/schc_cd');*

2. Create a new object for the Compressor-Decompressor.

    *var CD = new Compressor_Decompressor;*

3. Load the initial values to the Compressor-Decompressor.

    *CD.initializeCD();*

4. Add the rules to be used. Rules should be previously defined following the given format. (For the moment, the rules should be added in their correponding oreder, matching the context of the compressor in the ES)

    *CD.addRule(rule);*

Now the Compressor-Decompressor is all set up and ready to decompress received packets.
For every packet received the following methods should be used in order:   

5. The IPv6 IIDs depending on the rule could be obtained from L2, in this case the following method should be used to load the ES and LA IIDs to the Compressor-Decompressor.

    *CD.loadIIDs(ESiid,LAiid);*

6. The compressed packet received has to be loaded to the Compressor-Decompressor. In this method, the compressed packet is parsed into the rule, the values sent for the fields that have to receive something according to the rule and the payload.
    
    *CD.parseCompressedPacket(compressedPacket);*

7. Following the context of the rule received the decompression can be executed.

    *CD.decompressHeader();*

After the decompression, the decompressed header can then be accessed through the variable *CD.decompressed_header*.

The folder “javascript\test” contains a script called “testing.js” that can be used to test the decompression of different packets that follow a basic rule loaded as “rule0”. Other rules can be added following the rule format since the decompressor tolerate some flexibility.

The folder “javascript\examples” contains a script called “decompression_server.js” which shows how a server could be set up and use the module to decompress the packets received.

(ADD LIST OF POSSIBLE CDF)

# Appendix - Rule Format

An example of a rule format is shown. All fields should be included in a rule for a propper compression/decompression.

var rule0 = {
    "IP_version": {
    
        "targetValue": "6",
        
        "matchingOperator": "equal",
        
        "compDecompFct": "not-sent",
        
    },
    
    "IP_trafficClass": {
    
        "targetValue": "00",
        
        "matchingOperator": "equal",
        
        "compDecompFct": "not-sent",
        
    },
    
    "IP_flowLabel": {
    
        "targetValue": "00000",
        
        "matchingOperator": "equal",
        
        "compDecompFct": "not-sent",
        
    },
    
    "IP_payloadLength": {
    
        "targetValue": '',
        
        "matchingOperator": "ignore",
        
        "compDecompFct": "compute-IPv6-length",
        
    },
    
    "IP_nextHeader": {
    
        "targetValue": "11",
        
        "matchingOperator": "equal",
        
        "compDecompFct": "not-sent",
        
    },
    
    "IP_hopLimit": {
    
        "targetValue": "40",
        
        "matchingOperator": "equal",
        
        "compDecompFct": "not-sent",
        
    },
    
    "IP_prefixES": {
    
        "targetValue": "20010db80a0b12f0",
        
        "matchingOperator": "ignore",
        
        "compDecompFct": "not-sent",
        
    },
    
    "IP_iidES": {
    
        "targetValue": "",
        
        "matchingOperator": "equal",
        
        "compDecompFct": "ESiid-DID",
        
    },
    
    "IP_prefixLA": {
    
        "targetValue": "2d513de80a0b4df0",
        
        "matchingOperator": "equal",
        
        "compDecompFct": "not-sent",
        
    },
    
    "IP_iidLA": {
    
        "targetValue": "",
        
        "matchingOperator": "ignore",
        
        "compDecompFct": "LAiid-DID",
        
    },
    
    
    "UDP_PortES": {
    
        "targetValue": "1f90",
        
        "matchingOperator": "equal",
        
        "compDecompFct": "not-sent",
        
    },
    
    "UDP_PortLA": {
    
        "targetValue": "2382",
        
        "matchingOperator": "equal",
        
        "compDecompFct": "not-sent",
        
    },
    
    "UDP_length": {
    
        "targetValue": '',
        
        "matchingOperator": "ignore",
        
        "compDecompFct": "compute-UDP-length",
        
    },
    
    "UDP_checksum": {
    
        "targetValue": '',
        
        "matchingOperator": "ignore",
        
        "compDecompFct": "compute-UDP-checksum",
        
    },
    
    "CoAP_version": {
    
        "targetValue": "5",
        
        "matchingOperator": "equal",
        
        "compDecompFct": "not-sent",
        
    },
    
    "CoAP_type": {
    
        "targetValue": "5",
        
        "matchingOperator": "equal",
        
        "compDecompFct": "not-sent",
        
    },
    
    "CoAP_tokenLength": {
    
        "targetValue": "1",
        
        "matchingOperator": "equal",
        
        "compDecompFct": "not-sent",
        
    },
    
    "CoAP_code": {
    
        "targetValue": "02",
        
        "matchingOperator": "equal",
        
        "compDecompFct": "not-sent",
        
    },
    
    "CoAP_messageID": {
    
        "targetValue": "00",
        
        "matchingOperator": "MSB(8)",
        
        "compDecompFct": "LSB(8)",
        
    },
    
    "CoAP_token": {
    
        "targetValue": '',
        
        "matchingOperator": "ignore",
        
        "compDecompFct": "value-sent",
        
    }
};
